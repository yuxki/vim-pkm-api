*pkm.txt*  For Vim version 8.2   Last change: 2021/12/29

Customable Key Oriented Popup Menu.

Version: 0.1.0
Author: yuxki
License: MIT License
Repository: https://github.com/yuxki/vim-pkm-api

==============================================================================
CONTENTS 						*pkm-contents*

1. Introduction		|pkm-intro|
2. Usage		|pkm-usage|
3. Install		|pkm-install|
4. Interface		|pkm-interface|
   Popup Key Menu	|pkm-popup-key-menu|
   Handlers		|pkm-handlers|
   Props		|pkm-props|
   Prop Details		|pkm-prop-details|
   Other Functions	|pkm-other-functions|
   Variables		|pkm-variables|
5. Samples		|pkm-samples|

==============================================================================
1. Introduction						*pkm-intro*

The pkm (Popup Key Menu) is customable and the alphabet and number keys
oriented popup menu. See |popup.txt| for details on popup.

==============================================================================
2. Usage						*pkm-usage*

 +------------------------X
 | [r] red    [b] blue    |
 | [y] yellow [o] orange  |
 +------------------------+

This sample program open the above popup menu that prints color name
according to the the key. The key 'x' closes the popup. Set 0 to the
|pkm.xclose| to disable this util.

Note: See |pkm-samples| to get more "plugin like" samples.
>
 let s:colors = ['red', 'blue', 'yellow', 'orange']
 let s:popup_options = #{
  \ padding: [0, 1, 0, 1],
  \ border: [1, 1, 1, 1],
  \ }
 let s:pkm_id = ''

 function! SamplePkm()
   if !pkm#Exists(s:pkm_id)
     let s:pkm = pkm#PopupKeyMenu()		" #1
     let s:pkm.max_cols_lines = 2		" #2
     let s:pkm.keys ='rbyo'

     function! s:pkm.OnKeySelect(winid, index)  " #3
       echo s:colors[a:index]
     endfunction

     call s:pkm.Load(s:colors)			" #4
   endif

   call s:pkm.Open(s:popup_options)		" #5
   let s:pkm_id = s:pkm.pkm_id
 endfunction
<
#1 The constructed pkm |dict| is managed by |pkm.pkm_id| key in
the script variable dict ({ pkm_id : pkm_dict }). |pkm#Exists()| checks if
the pkm_id is exists in the script variable dict, and you can reuse the
pkm dict.

#2 The |pkm-props| changes the pkm popup behavior. In this sample,
'[key] item' pairs will be displayed with 2 columns, and '[key]' will be
the keys 'r', 'b', 'y', 'o'.

#3 The |pkm-handlers| can be used by overriding. The |pkm.OnKeySelect()| will be
called when the key is selected. In this case, the key 'r' returns 0, and the
key 'o' returns 3.

#4 The colors and the properties are loaded by the |pkm.Load()|. Now pkm
popup can be opend.

#5 The |pkm.Open()| calls |popup_create()| with the options argument. See
|popup_create-arguments| for details on the options.
>
 let s:colors = ['red', 'blue', 'yellow', 'orange',
      \ 'dark-red', 'dark-blue', 'dark-yellow', 'dark-orange',
      \ 'light-red', 'light-blue', 'light-yellow', 'light-orange']
<
If you load a List has items more than |pkm.key| length, items separated by
pages. On the default behavior, the key 'l' transits to next page, and the
key 'h' does the opposite of that. The page guide can be customized by
the |pkm.page_guides| property.

 +------------------------------------X
 | [r] red          [b] blue          |
 | [y] yellow       [o] orange        |
 |                (0) [L] >>          |
 +------------------------------------+

 +------------------------------------X
 | [r] dark-red     [b] dark-blue     |
 | [y] dark-yellow  [o] dark-orange   |
 |         << [H] (1) [L] >>          |
 +------------------------------------+

 +------------------------------------X
 | [r] light-red    [b] light-blue    |
 | [y] light-yellow [o] light-orange  |
 |         << [H] (2)                 |
 +------------------------------------+

==============================================================================
3. Install						*pkm-install*

With vim-plug:
>
 Plug 'yuxki/vim-pkm-api'
<
Combining your plugin:

Download and put the "autoload/pkm.vim" from

 https://github.com/yuxki/vim-pkm-api

into your plugin directory, and rename interface functions with a commad
like the following.
>
 sed -i -e 's|pkm#|foo#pkm#|g' path/to/your/plugin/autoload/foo/pkm.vim
<
==============================================================================
4. Interface						*pkm-interface*

------------------------------------------------------------------------------
POPUP KEY MENU						*pkm-popup-key-menu*


pkm#PopupKeyMenu()					*pkm#PopupKeyMenu()*

		Constuct and register the pkm dict into
		the unique "script variable dict" by the pkm_id key.
		This id is assigned from the unique "script variable number"
		that is incremented. >
			:call pkm#PopupKeyMenu()
			:echo pkm#PkmMenus()
			{'1000': {...}}

 			:call pkm#PopupKeyMenu()
			:echo pkm#PkmMenus()
			{'1000': {...}, '1001': {...}}
<

		Returns the constructed dict, which has |pkm.pkm_id|, it can
		be used to get or check existing the pkm dict. >
			:let pkm_id = ''
			:if !pkm#Exists(pkm_id)
			:  let pkm = pkm#PopupKeyMenu()
			:  let pkm_id = pkm.pkm_id
			:endif

pkm.Load({items})					*pkm.Load()*

		Load the {items} and some |pkm-props|. {items} is a
		string list, and a item is displayed next to a assigned key.
		As a result, the |pkm.pages| is created. >
			:let id = pkm#PopupKeyMenu()
			:let s:pkm.max_cols_lines = 2
			:let pkm.keys ='abcd'
			:call pkm.Load(items)
			:echo pkm#PkmMenus()[id].pages
			[['[a] AAA [b] BBB ', '[c] CCC [d] DDD ']]
<
		If items or loaded props are changed, you need reload
		with calling this method again.
		Loaded props are following:

			keys
			max_cols_lines
			col_border
			page_guide
			align
			col_width
			fix_width
			fix_height
			vertical
			xclose
			key_guide
			page_guides
			next_page_key
			prev_page_key

		Returns the self dict, so can construct ~ open in a line. >
			:call pkm#PopupKeyMenu().Load(items).Open(options)
<
pkm.Open({options})					*pkm.Open()*

		Create and open a pkm popup. {options} argument is
		|popup_create()| options. The filter and the callback, and the
		close (when the xclose is 1) options are reserved by this
		method. >
			:call pkm.Open(#{
 				\ padding: [0, 1, 0, 1],
 				\ border: [1, 1, 1, 1],
 				\ })
<
				+----------X
				| [a] AAA  |
				| [b] BBB  |
				| [c] CCC  |
				| [d] DDD  |
				+----------+

		Calls |pkm.OnOpen()| handler after a popup opened. If the
		|pkm.pages| is empty or the |pkm.winid| is exists in existing
		popup |window-ID|, does not anything, and returns.

		Returns the self dict. And this dict is set window-ID by this
		method. >
			:let pkm = pkm.Open()
			:hi MyPkmColor ctermbg=darkgreen guibg=darkgreen
			:call setwinvar(pkm.winid, '&wincolor', 'MyPkmColor')

pkm.Filter({winid}, {key})				*pkm.Filter()*

		The popup key menu's |popup-filter|.
		This method does the follwing actions in the order.

		1. Calls the |pkm.OnFilter()| handler.
		2. Closes the popup if the xclose is 1 and the key is 'x'
		3. Turns the page if the key is matched |pkm.next_page_key| or
		   |pkm.prev_page_key|.
		4. Calls the |pkm.OnKeySelect()| handler.if the key is matched
		   |pkm.keys|.

		Note: See |popup-filter| help for details on the popup-filter
		behaviors.

		Can be called directory:
			+-------------------X
			| [a] AAA [b] BBB   |
			|        (0) [L] >> |
			+-------------------+
>
			:call pkm.Filter(pkm.winid, 'L')
<
			+-------------------X
			| [a] CCC [b] DDD   |
			| << [H] (1)        |
			+-------------------+

		By default the filter returns TRUE and discards the key, and
		let Vim do not handle the key.

		To return FALSE and let Vim handle the key, set pkm.focus 0.
		It lets the filter return FALSE when the key is not matched
		the props, |pkm.next_page_key|, |pkm.next_page_key|, |pkm.keys|,
		'x'(when the |pkm.xclose| is 1). >
			:let pkm.focus = 0
<
		In an other way, return -1 in the |pkm.OnFilter()| handler
		and specify |filtermode| options for |popup_create()|.
		It lets the filter return FALSE immediately. The following
		example enables Vim to consume ":" and to enter Command-line
		mode, and disable the filter to filter the key except in
		Normal mode: >
			func! pkm.OnFilter(winid, key)
			  if a:key == ':'
			    return -1
			  endif
			  return 0
			endfunc
			call pkm.Open(#{filtermode: 'n'})


pkm.Remove()						*pkm.Remove()*

		Removes the self pkm dict from "script variable dict".

		This method does not close the popup. To not left the
		uncontrolable popup, call this method after closing: >
			func! pkm.OnClose(winid, key)
			  self.Remove()
			endfunc

------------------------------------------------------------------------------
HANDLERS						*pkm-handlers*


pkm.OnOpen({winid})					*pkm.OnOpen()*

		Called after opening the pkm popup in the |pkm.Open()|.
		Example: >
			func! pkm.OnOpen(winid)
			  hi MyPkmColor ctermbg=darkgreen guibg=darkgreen
			  call setwinvar(a:winid, '&wincolor', 'MyPkmColor')
			endfunc

pkm.OnFilter()					*pkm.OnFilter()*

		Called immediately after the |pkm.Filter()| invoked.
		Return value affects the |pkm.Filter()| behavior:

			 0 : Does not return immediately from the filter.
			     The return value is depend on |pkm.focus|.
			 1 : Returns immediately from the filter with TRUE.
			-1 : Returns immediately from the filter with FALSE.

		Examples:
			To hide the popup: >
			func! pkm.OnFilter(winid, key)
			  if a:key ==# 'H'
			    call popup_hide(a:winid)
			    return 1
			  endif
			  return 0
			endfunc
<
			To enter Command-line mode and Visual mode: >
			func! pkm.OnFilter(winid, key)
			  if index([':', 'v'], a:key) >= 0
			    return -1
			  endif
			  return 0
			endfunc

pkm.OnKeySelect({winid}, {index})			*pkm.OnKeySelect()*

		Called if the key is in the |pkm.keys| in |pkm.Filter()|. Returns
		from |pkm.Filter()| TRUE and the key is consumed by the filter.

		{index} is passed besed on lenght of items loaded by the
		|pkm.Load()|:
			+-------------------+  +-------------------+
			| [a] AAA [b] BBB   |  | [a] CCC [b] DDD   |
			|        (0) [L] >> |  | << [H] (1)        |
			+-------------------+  +-------------------+
			 key [a]: {index} 0	key [a]: {index} 2
			 key [b]: {index} 1	key [b]: {index} 3

		Example: >
			func! pkm.OnKeySelect(winid, index)
			  execute my_awesome_commands[a:index]
			  call popup_close(a:winid)
			endfunc

<
pkm.OnClose({winid}, {secondarg})				*pkm.OnClose()*

		Called after the pkm popup is closed. Actually, this handler
		is called by |popup-callback| and passed the same arguments,
		so that {secondarg} is the second argument of |popup_close()|.

		Example: >
			func! pkm.OnClose(winid, secondarg)
			  self.Remove()
			endfunc

------------------------------------------------------------------------------
PROPS							*pkm-props*
	winid
	pkm_id
	pages
	keys
	max_cols_lines
	col_border
	align
	col_width
	fix_width
	fix_height
	vertical
	xclose
	page_guide
	ignorecase
	next_page_key
	prev_page_key
	key_guide
	page_guides
	active_modes
	focus
------------------------------------------------------------------------------
PROP DETAILS						*pkm-prop-details*

pkm.winid						*pkm.winid*

		Write
pkm.pkm_id						*pkm.pkm_id*

		Write

pkm.pages						*pkm.pages*

		Write

pkm.keys						*pkm.keys*

		Default: 'abcdefimnopqrstuvwyz'

pkm.max_cols_lines					*pkm.max_cols_lines*

		Default: 1

pkm.col_border						*pkm.col_border*

		Default: ' '

pkm.align						*pkm.align*

		Default: 1

pkm.col_width						*pkm.col_width*

		Default: 'auto'

pkm.fix_width						*pkm.fix_width*

		Default: 0

pkm.fix_height						*pkm.fix_height*

		Default: 0

pkm.vertical						*pkm.vertical*

		Default: 0

pkm.xclose						*pkm.xclose*

		Default: 1

pkm.page_guide						*pkm.page_guide*

		Default: 1

pkm.ignorecase						*pkm.ignorecase*

		Default: 0

pkm.next_page_key					*pkm.next_page_key*

		Default: 'L'

pkm.prev_page_key					*pkm.prev_page_key*

		Default: 'H'

pkm.key_guide						*pkm.key_guide*

		Default: '[%k] '

pkm.page_guides						*pkm.page_guides*

		Default: [
		\ '       (%p) [%n] >>',
		\ '<< [%v] (%p) [%n] >>',
		\ '<< [%v] (%p)       ',
		\ ]


pkm.active_modes					*pkm.active_modes*

		Default: ['n']

pkm.focus						*pkm.focus*

		Default: 1

------------------------------------------------------------------------------
OTHER FUNCTIONS						*pkm-other-functions*

pkm#PkmMenus()						*pkm#PkmMenus()*

		Description about the function.

pkm#NextId()						*pkm#NextId()*

		Description about the function.

pkm#Clear()						*pkm#Clear()*

		Description about the function.

pkm#Exists({pkmid})					*pkm#Exists()*

		Description about the function.

------------------------------------------------------------------------------
VARIABLES						*pkm-variables*

						  *s:pkm_api_popup_key_menus*
s:pkm_api_popup_key_menus

		Description about the variable.


						*s:pkm_api_popup_key_menu_id*
s:pkm_api_popup_key_menu_id

		Description about the variable.
==============================================================================
SAMPLES							*pkm-samples*

==============================================================================
 vim:tw=78:ts=8:noet:ft=help:norl:
